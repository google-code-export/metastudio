import java.io.*;
import java.util.StringTokenizer;

import org.meta.common.*;
import org.meta.math.geom.*;
import org.meta.molecule.impl.*;
import org.meta.propertyreader.*;
import org.meta.molecule.property.electronic.*;
import org.meta.shell.idebeans.viewers.impl.moleculeviewer.*;
import org.meta.shell.idebeans.viewers.impl.moleculeviewer.graphicsengine.surfaces.*;

cubeReader(cubeFileName) {
    reader=openFile(cubeFileName);

    // keep reading till the required line reached
    while(true) {
      line = reader.readLine();
      if (line == null) continue;
      if (line.trim().equals("----- START OF CUBE FORMAT -----")) break;
    }

    reader.readLine(); reader.readLine();

    // then the grid property starts
    GridProperty property = new GridProperty();
    StringTokenizer tokenizer;
    String line;
    
    line = reader.readLine();    

    tokenizer = new StringTokenizer(line);

    int noOfAtoms = Math.abs(Integer.parseInt(tokenizer.nextToken()));

    print("Number of atoms: " + noOfAtoms);

    BoundingBox bb = new BoundingBox();
    bb.getUpperLeft().setX(angstroms(Double.parseDouble(tokenizer.nextToken())));
    bb.getUpperLeft().setY(angstroms(Double.parseDouble(tokenizer.nextToken())));
    bb.getUpperLeft().setZ(angstroms(Double.parseDouble(tokenizer.nextToken())));      

    // read NX, NY, NZ
    line = reader.readLine();
    tokenizer = new StringTokenizer(line);
    
    property.setNoOfPointsAlongX(Integer.parseInt(tokenizer.nextToken()));
    property.setXIncrement(angstroms(Double.parseDouble(tokenizer.nextToken())));

    // NY
    line = reader.readLine();
    tokenizer = new StringTokenizer(line);
    
    property.setNoOfPointsAlongY(Integer.parseInt(tokenizer.nextToken()));
    tokenizer.nextToken();
    property.setYIncrement(angstroms(Double.parseDouble(tokenizer.nextToken())));

    // NZ
    line = reader.readLine();
    tokenizer = new StringTokenizer(line);
    
    property.setNoOfPointsAlongZ(Integer.parseInt(tokenizer.nextToken()));
    tokenizer.nextToken(); tokenizer.nextToken();
    property.setZIncrement(angstroms(Double.parseDouble(tokenizer.nextToken())));

    // bottom right
    bb.getBottomRight().setX(bb.getUpperLeft().getX() 
                   + ((property.getNoOfPointsAlongX()+1)*property.getXIncrement()));
    bb.getBottomRight().setY(bb.getUpperLeft().getY()
                   + ((property.getNoOfPointsAlongY()+1)*property.getYIncrement()));
    bb.getBottomRight().setZ(bb.getUpperLeft().getZ()
                   + ((property.getNoOfPointsAlongZ()+1)*property.getZIncrement()));

    property.setBoundingBox(bb);

    print(property);

    // from the next line the Molecule entry starts
    for(i=0; i<noOfAtoms; i++) { 
      line = reader.readLine();
      print("mol:] " + line);
    }

    // set up the grid array to copy the function values
    int noOfGridPoints = property.getNumberOfGridPoints();
        
    double [] functionValues = new double[noOfGridPoints];

    // start a tokeniser to obtain all the values in the grid
    ScientificStreamTokenizer sTokenizer = new ScientificStreamTokenizer(reader.getStream()); 
        
    try {
        int ijkl = 0;
        N1 = property.getNoOfPointsAlongX();
        N2 = property.getNoOfPointsAlongY();
        N3 = property.getNoOfPointsAlongZ();
        for(int i=0; i<N1; i++) {
            for(int j=0; j<N2; j++) {
                for(int k=0; k<N3; k++) {
                   if (sTokenizer.nextToken() != StreamTokenizer.TT_NUMBER) {
                         throw new IOException("Could not understand format : " 
                                               + sTokenizer + " => " + sTokenizer.sval);
                   } else {
                     functionValues[ijkl] = sTokenizer.nval;
                   } // end  if
                   ijkl++;
                } // end for
            } // end for
         } // end for
    } catch (Exception e) {
         print("may be an error " + e.toString());
    } // end of try ... catch block

    // setup the function values in property object
    property.setFunctionValues(functionValues);

    reader.close();

    return property;
}

printStats(p) {
    negCount  = p.getNoOfNegativeFunctionValues();
    posCount  = p.getNoOfPositiveFunctionValues();
    minVal    = p.getMinFunctionValue();
    maxVal    = p.getMaxFunctionValue();
    minMaxDif = maxVal - minVal;

    fVals = p.getFunctionValues();
    N = p.getNumberOfGridPoints();

    avgPos = 0.0; avgNeg = 0.0;
    for(int i=0; i<N; i++) {
       if (fVals[i] >= 0.0) avgPos += fVals[i];
       else avgNeg += fVals[i];
    }
    
    avgPos = avgPos / posCount;
    avgNeg = avgNeg / negCount;

    print((new File(fl)).getName() + ", " + 
           negCount + ", " + 
           posCount + ", " + 
           minVal + ", " + 
           maxVal + ", " +
           minMaxDif  + ", " + 
           avgNeg + ", " + 
           avgPos + ", " +
           "\n");
}

fl = showFileDialog();
p = cubeReader(fl);
printStats(p);

